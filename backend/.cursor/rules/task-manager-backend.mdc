---
alwaysApply: true
---

# Task Manager Backend Rules

## Project Overview
This is the backend API for a task management application built with Node.js and Express. The backend provides RESTful endpoints for managing tasks, users, and authentication using SQLite as the database.

## Technology Stack
- **Runtime**: Node.js
- **Framework**: Express.js
- **Database**: SQLite (using sqlite3 package)
- **Authentication**: JWT (jsonwebtoken)
- **Password Hashing**: bcrypt
- **Environment Variables**: dotenv
- **Database Access**: Raw SQL queries (no ORM)

## Code Style & Conventions
- Use ES6+ syntax (const/let, arrow functions, async/await)
- Use camelCase for variables and functions
- Use PascalCase for classes and constructors
- Use UPPER_SNAKE_CASE for constants
- Use meaningful, descriptive names
- Keep functions small and focused on a single responsibility
- Add JSDoc comments for complex functions

## Project Structure
```
backend/
├── config/
│   └── database.js          # SQLite connection setup
├── controllers/             # Request handlers
├── middleware/              # Custom middleware (auth, validation, etc.)
├── models/                  # Database query functions (raw SQL)
├── routes/                  # Express route definitions
├── utils/                   # Helper functions (JWT, validation, etc.)
├── .env                     # Environment variables (not committed)
├── .env.example             # Example environment variables
└── server.js                # Application entry point
```

## Database Patterns (SQLite with Raw SQL)
- Use parameterized queries to prevent SQL injection
- Always use `?` placeholders for values in SQL queries
- Use transactions for multi-step operations
- Handle database errors appropriately
- Close database connections properly
- Use prepared statements for repeated queries

Example:
```javascript
db.run('INSERT INTO users (email, password) VALUES (?, ?)', [email, hashedPassword], function(err) {
  if (err) {
    // handle error
  }
  // handle success
});
```

## Authentication & Security
- Use JWT tokens for authentication
- Store JWT secret in environment variables
- Hash passwords with bcrypt (minimum 10 salt rounds)
- Never store plain text passwords
- Validate and sanitize all user input
- Use middleware to protect authenticated routes
- Set appropriate token expiration times
- Return generic error messages for authentication failures (don't reveal if user exists)

## API Design
- Follow RESTful conventions:
  - GET `/api/tasks` - Get all tasks
  - GET `/api/tasks/:id` - Get single task
  - POST `/api/tasks` - Create task
  - PUT `/api/tasks/:id` - Update task
  - DELETE `/api/tasks/:id` - Delete task
- Use consistent JSON response format:
  ```javascript
  { success: true, data: {...} }
  { success: false, error: "Error message" }
  ```
- Use appropriate HTTP status codes:
  - 200: Success
  - 201: Created
  - 400: Bad Request
  - 401: Unauthorized
  - 403: Forbidden
  - 404: Not Found
  - 500: Internal Server Error

## Error Handling
- Use try-catch blocks for async operations
- Create consistent error response format
- Log errors appropriately (console.error for development)
- Don't expose sensitive information in error messages
- Handle database errors gracefully
- Return user-friendly error messages

## Environment Variables
- Use dotenv to load environment variables
- Create `.env` file (add to .gitignore)
- Create `.env.example` with placeholder values
- Required variables:
  - `PORT` - Server port (default: 3000)
  - `JWT_SECRET` - Secret key for JWT signing
  - `DB_PATH` - Path to SQLite database file

## Middleware
- Use Express middleware for:
  - CORS configuration
  - JSON body parsing
  - Authentication verification
  - Request validation
  - Error handling

## Database Schema Guidelines
- Use INTEGER PRIMARY KEY for auto-incrementing IDs
- Use TEXT for strings
- Use INTEGER for booleans (0/1) or timestamps
- Add appropriate indexes for frequently queried columns
- Use foreign keys with proper constraints
- Add created_at and updated_at timestamps where relevant

## Testing Considerations
- Write unit tests for utility functions
- Write integration tests for API endpoints
- Use descriptive test names
- Test both success and error cases
- Mock database calls in unit tests

## Security Best Practices
- Always validate input before database operations
- Use parameterized queries (never string concatenation)
- Sanitize user input to prevent XSS
- Implement rate limiting for authentication endpoints
- Use HTTPS in production
- Keep dependencies updated
- Never commit `.env` file or secrets
